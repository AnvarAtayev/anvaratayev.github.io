<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns="http://www.w3.org/1999/xhtml" xmlns:x="https://www.texmacs.org/2002/extensions">
  <head>
    <title>No title</title>
    <meta content="TeXmacs 1.99.21" name="generator"></meta>
    <style type="text/css">
      body { text-align: justify } h5 { display: inline; padding-right: 1em }
      h6 { display: inline; padding-right: 1em } table { border-collapse:
      collapse } td { padding: 0.2em; vertical-align: baseline } dt { float:
      left; min-width: 1.75em; text-align: right; padding-right: 0.75em;
      font-weight: bold; } dd { margin-left: 2.75em; padding-bottom: 0.25em; }
      dd p { padding-top: 0em; } .subsup { display: inline; vertical-align:
      -0.2em } .subsup td { padding: 0px; text-align: left} .fraction {
      display: inline; vertical-align: -0.8em } .fraction td { padding: 0px;
      text-align: center } .wide { position: relative; margin-left: -0.4em }
      .accent { position: relative; margin-left: -0.4em; top: -0.1em }
      .title-block { width: 100%; text-align: center } .title-block p {
      margin: 0px } .compact-block p { margin-top: 0px; margin-bottom: 0px }
      .left-tab { text-align: left } .center-tab { text-align: center }
      .balloon-anchor { border-bottom: 1px dotted #000000; outline: none;
      cursor: help; position: relative; } .balloon-anchor [hidden] {
      margin-left: -999em; position: absolute; display: none; }
      .balloon-anchor: hover [hidden] { position: absolute; left: 1em; top:
      2em; z-index: 99; margin-left: 0; width: 500px; display: inline-block; }
      .balloon-body { } .ornament { border-width: 1px; border-style: solid;
      border-color: black; display: inline-block; padding: 0.2em; } .right-tab
      { float: right; position: relative; top: -1em; } .no-breaks {
      white-space: nowrap; } 
    </style>
    <link href="../resources/notes-base.css" type="text/css" rel="stylesheet"></link>
  </head>
  <body>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      TeXmacs can be used to build websites, in fact <a href="https://texmacs.github.io/notes">this</a> blog,
      the main <a href="www.texmacs.org">TeXmacs website</a> and a couple of other websites
      (e.g. one <a href="https://www.texmacs.org/joris/main/joris.html">here</a> and another one <a href="http://www.mathemagix.org/www/mmdoc/doc/html/main/index.en.html">here</a>) are
      currently written and maintained exclusively within TeXmacs. 
    </p>
    <p>
      To avoid the need of exporting manually every single page to HTML, some
      support has been added to build websites in the form of Scheme
      procedures, to be found in the module  (which can be found at ). The two
      relevant exported procedures are  and . 
    </p>
    <p>
      For example the user can invoke TeXmacs for the command line with
      something like
    </p>
    <p>
      
    </p>
    <p>
      which executes (option ) the Scheme command 
    </p>
    <p>
      
    </p>
    <p>
      and then exits (option ). Here <var>source-dir</var> and
      <var>target-dir</var> are two filesystem paths to the source and target
      directories for the conversion. The procedure  will take every  file in
      <var>source-dir</var>, convert it to its HTML counterpart  and save it
      in <var>target-dir</var>, all the other file types are just copied (see
      the sources for more details).  will convert only files which are newer
      than their counterpart in <var>target-dir</var>, if it exists. This is
      suitable for incremental updating a website which has been already
      generated at least once with .
    </p>
    <p>
      TeXmacs (here we refer to version 1.99.15 but this functionality existed
      already for some time) disposes of menu items to initiate both
      operations (creation and update). They can be found in  and . The dots
      () indicate that both items will execute some operation only after an
      interaction with the user (this is standard for all menu items, see e.g.
      ). In particular in this case these items calls the scheme procedures 
      or . The first, for example, looks like
    </p>
    <p>
      
    </p>
    <p>
      The declaration  indicates to TeXmacs that this procedur will prompt the
      user for some information. In particular, the dots in the menu item are
      added automatically by TeXmacs to reflect this declaration. The meaning
      of the actual code is quite intuitive: the procedure  prompt the user
      for some information, the UI is supposed to show somehow the string  to
      give an hint to the user about the content of the information required.
      The argument  indicates that valid results should be an  URL pointing to
      a directory in the filesystem. Finally the third argument to  is a
      Scheme closure accepting one argument. When this procedure is evaluated,
      it initiate a UI dialog with the user which can select a directory and
      then press &ldquo;Ok&rdquo; to confirm the selection. At this point the
      closure is called with an argument given by a string representing the
      URL just chosen. In the case above this result appears in the variable .
      Subsequently the closure evaluate an additional  invocation, which asks
      for a destination directory an provide a second closure which looks like
    </p>
    <p>
      
    </p>
    <p>
      This closure receives the destination directory in the variable  and has
      also access to the variable  because this last variable is visible
      (thanks to the lexical scoping of Scheme) to all the expressions inside
      the first . As a result the procedure  will be invocated with the user
      provided values for  and  and two additional boolean arguments (the
      first indicates whether we need to update or not and we will ignore the
      second here).
    </p>
    <p>
      Albeit  is easy to understand and write, it is not very convenient,
      since it does not remember the user's choices from previous interactions
      and oblige the user to repetitive actions, for example when developing
      some new feature of the site which requires frequent updating. 
    </p>
    <p>
      
    </p>
    <p>
      The goal of this article is to use  TeXmacs Scheme widgets to develop a
      new dialog which allow a nicer interaction with the user. 
    </p>
    <p>
      In particular we want to remember previous choices and give a more
      comprehensive perspective of the parameters in a single window, instead
      of proposint to the users a sequence of questions without any trace of
      the current state of the interaction. The following picture shows the
      design we aim for for this dialog:
    </p>
    <p>
      
    </p>
    <p>
      This dialog will have to be initiated by a procedure (with no
      parameters) which we will call . Later on we can associate this function
      to some menu item to give easy access to the user to it. We have to
      manage three values: the source directory, the target directory and a
      boolean value to indicate creation or update. The function must read 
      these values from a store (persistent through executions of the
      program), set up the dialog with these values, run the interaction,
      retrive the values after it and proceed with the suitable actions
      according to the new values. In particular, if the user didn't canceled
      the operation, we need to store away the new values for future
      invocations. This persistency of the information can be obtained by
      leveraging TeXmacs preference system, in particular we have two
      procedures  and  at our disposal. Their use is very simple: we can
      associate strings to given labels (also strings), the associations will
      persist across executions. If a label do not have any associated values
      so far  will return the string . A possible form of  is then the
      following:
    </p>
    <p>
      
    </p>
    <p>
      We choose labels , ,  for the three parameters. The  initialises local
      variable with the previous values of the parameters and then we invoke .
      This procedure takes two arguments  and : the first is a <i>widget</i>
      constructed via  and the second is a closure which will be passed to the
      widget.  The actual widget is constructed in the invocation to  which
      returns the executable code which will eventually display the dialog in
      Fig.<a href="#fig:dialog">1</a>. 
    </p>
    <p>
      This is achieved thanks to a custom description language accessed via
      the  macro.
    </p>
    <p>
      
    </p>
    <p>
      The macro  allows to use Scheme forms to construct a wide variety of UI
      elements from a set of basic <i>primitive</i> elements. For detailed
      information please refert to . Our goal here is to provide an example of
      how the technique described in the help pages apply to our present
      problem.
    </p>
    <p>
      Let us give right away a possibile definition for :
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      Note that all this should not be understood as <i>standard</i> Scheme
      code: the evaluation rules of Scheme are superseded by the macro  which
      will receive in input the description above and will use it to
      <i>compile</i> this description of a widget to a sequence of invocation
      of Scheme procedures. In this way we can provide a high-level
      description of widgets without need to code them in Scheme with all the
      gory details.  will take care of this for us. 
    </p>
    <p>
      Let us describe the meaning of some of markup tags used above
    </p>
    <ul>
      <li>
        <p>
          describes a widget which contains other UI elements and pad them
          with some space around;
        </p>
      </li>
      <li>
        <p>
          compose its arguments in a vertical list of UI elements;
        </p>
      </li>
      <li>
        <p>
          do the same but horizontally;
        </p>
      </li>
      <li>
        <p>
          , ,  are primitive elements (i.e. their definition is complete
          without referring to other content) which indicate various kind of
          spacing among the sorrounding elements;
        </p>
      </li>
      <li>
        <p>
          define a UI element which show the given string;
        </p>
      </li>
      <li>
        <p>
          indicates that the widget  must be refreshed when the procedure  is
          evaluated. It allow widgets to dynamically change in response to
          some action happening elsewhere in the code.
        </p>
      </li>
      <li>
        <p>
          represents an text input UI element which accepts file names and
          which will have a horizontal size of 40em. The  form will be
          evaluated every time the text field change, within that form the
          symbol  refers to the value of the text field, if  is  then the
          evaluation is not a result of an interaction with the user, so one
          has to check for this (It is not clear to me the reasons of this
          design, but it happens to be so, a deeper analysis of  inner design
          would be needed to get a grasp on this).
        </p>
      </li>
      <li>
        <p>
          describe a row of buttons with various labels. When they are
          pushed the respective forms are evaluated. For example, in the code
          above, the first button calls the function  with parameters as
          follows:
        </p>
        <p>
          
        </p>
        <p>
          This function (implemented in C++) opens the GUI file chooser dialog
          and initiate the modal interaction with the user to ask her a path
          of kind . The default directory is given by . When the user
          terminates the dialog pressing the &ldquo;Open&rdquo; button, then
          the chosen URL is passed to the closure in the variable , we store
          this value in the  variable (which is visible in all the syntactic
          context of , i.e. in the whole definition of the widget, and then we
          invoke  to update the corresponding  widget, i.e. update the text
          field with the appropriate value.
        </p>
      </li>
      <li>
        <p>
          describes a UI checkbox which takes its value from the  and which
          when switched (i.e. toggle its state) evaluates the form  with the
          symbol  evaluating to the current state of the checkbox.
        </p>
      </li>
      <li>
        <p>
          describe the buttons which should be located in the bottom right
          corner of the dialog. Typically these are the &ldquo;Cancel&rdquo;
          and &ldquo;Ok&rdquo; buttons. In our case we want to show a
          different label whether we are going to &ldquo;Create&rdquo; the
          site or only &ldquo;Update&rdquo; it.
        </p>
      </li>
    </ul>
    <p>
      Note the use of the parameter  which will be passed to  by . That is, 
      expects as its argument  a closure with one argument (i.e. ) and 
      another closure (with arbitrary many arguments) and upon execution, it
      call the closure  with  as argument. Therefore in the widget we have
      that  points to the closure . In our case calling  inside the widget
      will result in the evaluation of the closure
    </p>
    <p>
      
    </p>
    <p>
      with  set to  and with the other three argument set to the appropriate
      values. We can then finalize the interaction by storing away the values
      into the program's preferences and either call  or .
    </p>
    <p>
      
    </p>
  </body>
</html>